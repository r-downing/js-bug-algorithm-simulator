<!DOCTYPE html>
<html>
<head>
	<script src="https://code.jquery.com/jquery-3.2.1.slim.min.js"></script>
	<script type="text/javascript">
//https://stackoverflow.com/questions/29261304/how-to-get-the-click-coordinates-relative-to-svg-element-holding-the-onclick-lis
//https://stackoverflow.com/questions/6858479/rectangle-coordinates-after-transform
		 $( document ).ready( function(){
// Find your root SVG element
			var svg = document.querySelector('svg');

			var drawnCircle;
			var drawing = false, dragging = false, hp;
			var draggedCircle;

			var drawingLines=[];

// Create an SVGPoint for future math
			var pt = svg.createSVGPoint();

// Get point in global SVG space
			function cursorPoint(evt){
				pt.x = evt.clientX; pt.y = evt.clientY;
				return pt.matrixTransform(svg.getScreenCTM().inverse());
			}

			svg.addEventListener('dblclick',function(evt){
				hp = cursorPoint(evt);

				$('polygon').each(function(){
					if(pointInsidePolygon(hp,this)) $(this).remove();
				});

				if(drawing && drawingLines.length>2){
					var pointsString="";
					for(i=0; i<drawingLines.length;i++){
						pointsString+=drawingLines[i].attr('x1')+","+drawingLines[i].attr('y1')+" ";
					}
					$(document.createElementNS('http://www.w3.org/2000/svg', "polygon"))
						.attr('fill','blue')
						.attr('points',pointsString)
						.attr('fill-rule','evenodd')
						.addClass('drawn')
						.appendTo($('#mydrawing'));
				}
				drawing=false;
				$(drawingLines).each(function(){this.remove();});
				drawingLines=[];


			},false);

			svg.addEventListener('mousedown',function(evt){
				var loc = cursorPoint(evt);
				drawing=true;
				hp = loc;

				$('.draggable').each(function(){
					if(Math.hypot(($(this).attr('cx')-hp.x),($(this).attr('cy')-hp.y))<$(this).attr('r')) {
						dragging=true;
						drawing=false;
						draggedCircle=$(this);
					}
				});



				if(drawing && (drawingLines.length==0 || Math.hypot(drawingLines[drawingLines.length-1].attr('x1')-loc.x,drawingLines[drawingLines.length-1].attr('y1')-loc.y)>5)){
					drawingLines.push(
						$(document.createElementNS('http://www.w3.org/2000/svg', "line"))
							.attr('x1',loc.x)
							.attr('x2',loc.x)
							.attr('y1',loc.y)
							.attr('y2',loc.y)
							.attr('r',3)
							.attr('stroke','blue')
							.attr('stroke-width',1)
							//.addClass('drawn')
							.appendTo($('#mydrawing'))
					);
				}

			},false);

			svg.addEventListener('mousemove',function(evt){
				var loc = cursorPoint(evt);

				if(drawing && drawingLines.length){
					drawingLines[drawingLines.length-1].attr('x2',loc.x).attr('y2',loc.y);
				}

				if(dragging) {
					draggedCircle.attr('cx',loc.x).attr('cy',loc.y);
				}


			},false);

			svg.addEventListener('mouseup',function(evt){

//drawing = false;
				dragging = false;
				var loc = cursorPoint(evt);
// Use loc.x and loc.y here

			},false);

			var dx, dy, movementTimer;
			 var currentAlgorithm;
			 
			 function startRunning(){
					movementTimer = setInterval(function(){
					currentAlgorithm();
					//runBug2();

					if(Math.hypot(GX()-RX(),GY()-RY())>1 && (dx!=0 || dy!=0)){
						var speedNorm = Math.hypot(dx,dy)/.5;
						$('#robot').attr('cx',RX()+dx/speedNorm);
						$('#robot').attr('cy',RY()+dy/speedNorm);

						$(document.createElementNS('http://www.w3.org/2000/svg', "circle"))
							.attr('cx',RX())
							.attr('cy',RY())
							.attr('r',1)
							.attr('fill','orange')
							.addClass('path')
							.appendTo($('#mydrawing'));

					}
				}, 10);
			 }

			$("#runButton").click(function(){
				$(".path").remove();
				currentAlgorithm = runRightTurn;
				startRunning();
			});
			 
			 $("#stopButton").click(function(){clearInterval(movementTimer)});

			function pointInsidePolygon(p, poly){
				var intersects = [], n=0;
				for(i=0; i<poly.points.length;i++) {
					var x1=poly.points[i].x, y1=poly.points[i].y, x2=poly.points[(i+1)%poly.points.length].x, y2=poly.points[(i+1)%poly.points.length].y;

					if((y1 <= p.y && p.y<= y2) || (y2 <= p.y && p.y <= y1)) {
						if(x1==x2){	//vertical line
							intersects.push(x1);
						} else {
							var m = (y2-y1)/(x2-x1);
							var x = (p.y-y1)/m + x1;
							intersects.push(x);
						}
					}

				}
				for(i=0;i<intersects.length;i++){
					if(intersects[i]<p.x) n++;
				}
				return ((n%2) != 0);
			}


//https://stackoverflow.com/questions/849211/shortest-distance-between-a-point-and-a-line-segment

			function closestPointOnSegment(x, y, x1, y1, x2, y2) {

				var A = x - x1;
				var B = y - y1;
				var C = x2 - x1;
				var D = y2 - y1;

				var dot = A * C + B * D;
				var len_sq = C * C + D * D;
				var param = -1;
				if (len_sq != 0) //in case of 0 length line
					param = dot / len_sq;

				var xx, yy;

				if (param < 0) {
					xx = x1;
					yy = y1;
				}
				else if (param > 1) {
					xx = x2;
					yy = y2;
				}
				else {
					xx = x1 + param * C;
					yy = y1 + param * D;
				}

				var dx = x - xx;
				var dy = y - yy;
				return {x:xx,y:yy};
			}

			function closestPointOnPoly(p, poly){
				var md=1e6, cp;
				for(i=0; i<poly.points.length;i++) {

					var x1=poly.points[i].x, y1=poly.points[i].y, x2=poly.points[(i+1)%poly.points.length].x, y2=poly.points[(i+1)%poly.points.length].y;
					var c = closestPointOnSegment(p.x,p.y,x1,y1,x2,y2);
					var cd = Math.hypot(p.x-c.x,p.y-c.y);
					if(cd<md){
						md = cd;
						cp = c;
					}
				}
//console.log(cp);
				if(cp === undefined) alert(p.x + "cp undefined");
				if(isNaN(cp.x)) alert("cp is nan");
				return cp;
			}

			function RX() {
				return parseFloat($('#robot').attr('cx'));
			}
			function RY() {
				return parseFloat($('#robot').attr('cy'));
			}
			function GX() {
				return parseFloat($('#goal').attr('cx'));
			}
			function GY() {
				return parseFloat($('#goal').attr('cy'));
			}
			function RR() {
				return parseFloat($('#robot').attr('r'));
			}

			function collision(){
				var p = false;
				var md=0;//1e6;
				$('.drawn').each(function(){
					var cp = closestPointOnPoly({x:RX(),y:RY()},this);
					var d = Math.hypot((cp.x-RX()),(cp.y-RY())) - (RR());
					if (d<md) {
						md = d;
						if(d<=0){
							p=cp;
							/*
							 p=[];
							 var ang = Math.atan2((cp.y-RY()), (cp.x-RX()));
							 p.x = RX() + RR()*Math.cos(ang);
							 p.y = RY() + RR()*Math.sin(ang);
							 */
						}
					}
				});
				return p;
			}

			function runRightTurn(){
				dx = GX() - RX();	//go straight towards goal
				dy = GY() - RY();
				var cp = collision();
				if(cp){
					if((dy*(cp.y-RY())+dx*(cp.x-RX()))>0){ //if collision point is in path of robot +-90 degrees
						dx = RY() - cp.y; //turn 90 degrees to the right
						dy = cp.x - RX();
					}//if...
				}//if(cp)
			}//runBug1



			var bug2={following:false,leaving:false};

			function runBug2(){
				dx = GX() - RX();
				dy = GY() - RY();
				var cp = collision();
				if(cp && !bug2.leaving) {
					if(!bug2.following){
						//bug2.heading = Math.atan2(GY() - RY(), GX() - RX());
						bug2.following = true;
						bug2.startPoint = {x:RX(),y:RY()};
						console.log(bug2.startPoint);
					}
					var cs = closestPointOnSegment(RX(), RY(), bug2.startPoint.x, bug2.startPoint.y, GX(), GY());


					if(((bug2.startPoint.x-GX())*(cp.x-RX()) + (bug2.startPoint.y-GY())*(cp.y-RY()))>0  && Math.hypot(cs.x-RX(),cs.y-RY())<2) {
						console.log("stop following");
						bug2.following = false;
						bug2.leaving=true;
						dx = GX() - RX();
						dy = GY() - RY();
					}
					dx = RY() - cp.y;
					dy = cp.x - RX();
					bug2.lastContact = {x:cp.x,y:cp.y};
				} else if (bug2.following){
					var cs = closestPointOnSegment(RX(), RY(), bug2.lastContact.x, bug2.lastContact.y, GX(), GY());
					dx = cs.x - RX();
					dy = cs.y - RY();
				}
				if(!cp){
					bug2.leaving=false;
				}

			};
		});
	</script>
</head>

<body>

<svg id="mydrawing" width="600" height="400" style="border:1px solid black">
	<circle class="draggable" id="robot" cx="50" cy="50" r="20" fill="red" />
	<circle class="draggable" id="goal" cx="550" cy="350" r="18" fill="green" />
</svg><br/>
<a id="runButton">run</a>
<a id="stopButton">stop</a>


</body>
</html>
